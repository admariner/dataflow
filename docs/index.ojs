/*
FileAttachments: 
  package.json: ../package.json
*/
nav = html`<nav>
<h1 id=title>Dataflow Documentation</h1>

<span class=version>v${(await FileAttachment("package.json").json()).version}</span>

<a href="https://github.com/asg017/dataflow" style="color: black; ">
  <i class="bx bxl-github" style=" font-weight: 900; font-size: 1.5rem;"></i>
  <span style="font-size: 1.5rem; line-height: 1.5rem; font-weight: 500;">Github</span>
</a>` 

content = html`<div class=container>
  ${toc()}
  <article class=content>
    ${pages[currentI]()}
  </article>
</div>`


navParent = {
  nav.parentElement.classList.add("nav-parent");
  invalidation.then(() => nav.parentElement.classList.remove("nav-parent"));
  return html`<span>`;
}

md`---`


md`👇🏼 Everything below this line won't appear after we compile the docs`

pageMeta = pages.map(p=>{
  const dom = p();
  const h2 = dom.querySelector("h2");
  return {
      header: h2 && h2.textContent,
      id: h2 && h2.getAttribute("id")
  }
})

pageMeta

mutable currentI = {
  const i = pageMeta.findIndex(p=>p.id === window.location.hash.substring(1));
  if(i >=0) return i;
  return 0;
}

hash = {
  if(window.location.hash) window.scrollTo(0, 0);

  window.location.hash = pageMeta[currentI].id;
  document.title = `${pageMeta[currentI].header} / Dataflow Documentation`;
  return html`<span>`;
}

intro = () => md`## Introduction

too begin

shake
fellas in my hair
`

quickstart = () => md`
## Quickstart + Installation

Dataflow is a program that you install on your computer and use on the command line. \`dataflow run\` will start a dev sever that enable a live editing experience for your \`.ojs\` notebook files, and \`dataflow export\` will compile thise files into re-usable JavaScript ES modules for use in other projects.

### Install

\`dataflow\` is available on npm.

~~~bash
npm install @alex.garcia/dataflow

dataflow --help

# Alternatively, yarn.

yarn add @alex.garcia/dataflow

dataflow --help
~~~

### \`dataflow run\`



### \`dataflow compile\`


### .ojs Files

In Dataflow, you work with .ojs files, which has a similar vibe as JavaScript, but with key differences. If you copy+paste the cells found in Observable notebooks at observablehq.com into a new file by itself, then that would be an .ojs file!

Here's an example:

~~~javascript
// example.ojs

viewof a = html\`<input type=number value=20>\`

b = 2

c = a + b

everySecond = {
  let i = 0;
  while(true) {
    yield Promises.delay(1000, ++i)
  }
}

md\`It's been \${everySecond} seconds since everySecond has started.\`
~~~


Cells are written one after the other, where the entire \`example.ojs\` file is analagous to a single Observable notebook.


To run the file above:

~~~bash
dataflow run example.ojs
~~~

A server will start at http://localhost:8080, and if you navigate there, you will have a live rendered output of the \`example.ojs\` file.

Every change to the example.ojs file will automatically update. Every new cell, deleted cell, even re-arranged cells with automatically update all connected clients.

This also means you can use whatever text editor you want: VS Code, vim, nano, whatever can edit a file!


See [Observable’s not JavaScript](https://observablehq.com/@observablehq/observables-not-javascript) for a clearer look at what makes Observable syntax different from JavaScript.


### Standard Library (built-in cells)

Just like observablehq.com, Dataflow uses the [Observable notebook Standard Library](https://github.com/observablehq/stdlib), so cells like \`Promises\`, \`html\`, \`md\`, \`require\`, and more all are builtin by default. \`viewof\` and \`mutable\` cells are also supported.

One key difference with observablehq.com: The builtin cells for \`html\` and \`svg\` use [@observablehq/htl](https://github.com/observablehq/htl) instead. This means that not all notebooks found on observablehq.com will work when importing from Dataflow, but the API is similar enough to make upgrades only take a few minutes.

`;


stdlib = () => md`## Custom Standard Libraries
The base [Observable standard library](https://github.com/observablehq/stdlib) is great, but you may want your own custom builtin cells for your own workflow. The \`--stdlib\` flag can specify a configuration file where you can add more builtin cells.

~~~
dataflow run example.ojs --stdlib custom_stdlib.js
~~~

### stdlib.js Format

Inside your stdlib file, you must define a object on \`window.DATAFLOW_STDLIB\` like so:

~~~javascript
window.DATAFLOW_STDLIB = {
  constants: {
    name: "alex",
  },
  dependency: {
    require: {
      moment: require => require("moment")
    }
  }
}
~~~

The \`window.DATAFLOW_STDLIB\` object can define two different types of builtin cells: "constant" and "dependency" cells. 

### Constant cells

Constant cells are cells that do not use other stdlib cells in its defintion, like strings, functions, or numbers. \`window.DATAFLOW_STDLIB.constants\` is an object where the keys are the names of the builtin cells you want to include, and the values are the raw values that the cell will resolve to. 

~~~js
window.DATAFLOW_STDLIB = {
  constants: {
    red1: "#ff0000",
    red2: "#dd2222",
    upper: () => s => s.toUpperCase()
  }
}
~~~

TODO test

Here, a new builtin cell \`red1\` would have a value of \`"#ff0000"\`, \`red2\` would have \`"#dd2222"\`, and \`upper\` would be a function that upper-cases a given string.

Note: if you are defining a function, it [must be wrapped in a function](https://github.com/observablehq/runtime/issues/195), which is why \`window.DATAFLOW_STDLIB.constants.upper\` is a function that returns a function. 

These cells can be referenced in any \`.ojs\` file without needing to import or require, like so:

~~~js
html\`<div style="color: \${red1};"> I'm red! </div>\`

md\`\${upper("i am so loud")}\`
~~~


### Dependency cells

Depedency cells depend on another builtin cell. \`window.DATAFLOW_STDLIB.dependency\` is an object where the keys are previously defined builtin cells, and the values are objects where *those* keys are the name of *new* builtin cells to define, and the values are a function that is called with the resolved dependent builtin. 


~~~javascript
window.DATAFLOW_STDLIB = {
  dependency: {
    require: {
      d3: (require) => require("d3@5"),
      _: (require) => require("lodash"),
    },
    svg: {
      logo: (svg) =>
        svg\`<svg width=100 height=100>
          <rect width=100 height=100 fill=lightpink></rect>
          <circle cx=50 cy=50 r=40 fill=blue></circle>\`,
    },
    d3: {
      fakeData: (d3) => d3.range(200),
    },
  },
};
~~~

Here, in order to define \`d3\` and \`_\` as builtin cells, then \`require\`


2. \`d3\` and \`_\`, builtin cells that have a dependency to the \`require\` builtin cell. \`window.DATAFLOW_STDLIB.dependency\` is an object where the keys are other previously defined builtin cells, and the values are an object where _those_ keys are the name of _new_ builtin cells to define, and the values are a function is called with the resolved dependent builtin. Here, \`d3: (require) => require("d3@5")\` means "defined a new builtin \`d3\` that is dependent on the \`require\` builtin, and the definition is \`require("d3@5")\`.
3. \`logo\`, a cell that returns a simple SVG image.
4. \`fakeData\`, a builtin that relies on the neww builtin \`d3\` added above.

To use these builtins in an \`.ojs\` file, just reference it like any other stdlib cell! No need for importing or requiring.

~~~javascript
// example.ojs
html\`<div style="background-color: \${red1}">red1</div>\`;

html\`<div style="background-color: \${red2}">red2</div>\`;

html\`<div style="background-color: \${red3}">red3</div>\`;

d3.json("https://api.github.com/emojis");

_.partition([1, 2, 3, 4], (n) => n % 2);

logo;

d3.sum(fakeData);
~~~

### This will change

\`window.DATAFLOW_STDLIB\` is pretty awkward and limiting, so I plan to change this API in the future. Follow [#16](https://github.com/asg017/dataflow/issues/16) for more.67
`

fileattachments = ()=>md`## File Attachments

Filesystem access from a Dataflow instance is possible! You'll have to explicitly allow access from the \`dataflow run\` command with the \`--allow-file-attachments\` option like so:

~~~bash
dataflow run example.ojs --allow-file-attachments
~~~

### Regular File Attachments

FileAttachments paths are defined in a configuration comment at the very top of a \`.ojs\` file. For example:

~~~javascript
/*
FileAttachments:
  a.txt: ./path/to/a.txt
  image.png: ./path/to/image.png
*/

a = FileAttachment("a.txt").text();

md\`Contents of a.txt: \${a}\`;

img = FileAttachment("image.png").image();
~~~

The top comment must be a \`/* ... */\` style comment, where the body is a YAML object, with a single key \`FileAttachments\`, which defines an object where the keys are the "API-friendly" name of a file attachment, and the values are the path relative to the \`.ojs\` file of the FileAttachment.

### Live File Attachments

Live File Attachments are a Dataflow-specific feature that is only available in the \`dataflow run\` command (ie, not in compiled notebooks). Live File Attachments "watch" for live updates to a file attachment. 

\`LiveFileAttachment\` is a builtin cell that takes in the name of a FileAttachment and returns an async generator that yields the current value of the FileAttachment. For example:

\`\`\`js
/*
FileAttachments:
    data.csv: ./path/to/file.csv
*/

csvFile = LiveFileAttachment("data.csv")

data = csvFile.csv({typed: true}) // [{name: "alex", value: 23 ...}]
\`\`\`

Whenever \`./path/to/file.csv\` gets changed (new contents, changed file metadata, etc.), then \`csvFile\` will yield a new value, causing downstream cells like \`data\` to refresh with new data. 

Remember, \`LiveFileAttachment\` returns an async generator, NOT the actual file attachment object, so it's not 100% compatible with the \`FileAttachment\` API. If you assign the return value of \`LiveFileAttachment("data.csv")\` to its own cell (\`csvFile\` in the example above), then you can reference that cell as a file attachment object like normal, thanks to the Observable runtime. 


`


secrets = ()=>md`## Secrets

Secrets can be passed in from the \`dataflow run\` CLI. Keep in mind, there's no encryption or anything fancy going on with Secrets, think of them as a simple way to avoid writing secrets directly in source code.

~~~bash
dataflow run example.ojs --allow-secrets \\
    --secret API_TOKEN:$API_TOKEN \\
    --secret PASSWORD:hunter2
~~~

~~~javascript
// contents of the API_TOKEN environment  variable
apiToken = Secret("API_TOKEN");

// "hunter2"
password = Secret("PASSWORD");
~~~

One key difference here from [observablehq.com Secrets](https://observablehq.com/@observablehq/secrets): a \`Secret("key")\` call returns a Promise, not the secret directly.

Secrets are not supported when compiling notebooks with \`dataflow export\`.
`

importing = ()=>md`## Importing notebooks

### Local \`.ojs\` files


Local \`.ojs\` files can be imported! They will be compiled to ES modules ✨on the fly✨. Say you have \`submodule.ojs\`:

~~~javascript
// submodule.ojs

d3 = require("d3-array", "d3-random");

n = 10;

chart = svg\`<svg width=100 height=100>
\${d3
  .range(n)
  .map(
    (d) =>
      svg\`<circle r=2 fill=pink cx=\${d3.randomUniform(
        100
      )()} cy=\${d3.randomUniform(100)()}>\`
  )}\`;
~~~

And \`main.ojs\` in the same directory:

~~~javascript
// main.ojs

n = html\`<input type=range value=15 min=1 max=50>\`

import {chart} with {n} from "submodule.ojs"

chart
~~~


Running with \`dataflow run main.ojs\` will show how \`main.ojs\` imports the \`chart\` cell from \`submodule.ojs\`.

### observablehq.com Notebooks

Import with the notebook's full URL. Note that \`"@d3/bar-chart"\` alone wouldn't work, the full link \`"https://observablehq.com/@d3/bar-chart"\` works.

~~~javascript
viewof color = html\`<input type=color value="#c8ce57">\`

import {chart} with {color} from "https://observablehq.com/@d3/bar-chart"

import {Checkbox} from "https://observablehq.com/@observablehq/input-checkbox"

viewof selection = Checkbox(["Alameda", "Alpine" ,"Los Angeles", "San Diego"])

~~~

Note that because of differences between Dataflow's and observablehq's standard library, notebooks that rely on the old \`html\` builtin variables may behave differently in Dataflow. For example, the [\`@jashkenas/inputs\`](https://observablehq.com/@jashkenas/inputs) notebook uses the old \`html\` cell in a backward incompatible way, so it can't be imported cleanly. An alternative is [\`@observablehq/inputs\`](https://observablehq.com/@observablehq/inputs), or see [issue #2](https://github.com/asg017/dataflow/issues/2) for more workarounds.`

compiling = () => md`## Compiling Notebooks

Your \`.ojs\` files can be compiled to ES modules for easier integrations with other tools, similar to the [Advanced Embedding and Downloading
](https://observablehq.com/@observablehq/downloading-and-embedding-notebooks) on observablehq.com. These compiled files could be inclued in other projects like React apps, SPAs, or any other place the web can reach.

Compiling does **not** bundle everything needed to run an Observable notebook. You will still need to include the Observable runtime when embeding your notebooks elsewhere, and any dynamically fetched dependencies (like \`require()\` or \`import()\`) inside your code will not be included in the compiled bundle. 

### FileAttachments


### Custom Standard Libraries

### Secrets

https://github.com/asg017/dataflow/issues/17`

production = () => md`## Using Dataflow

### ObservableHQ vs. Dataflow

Here are some features that Observable notebooks on observablehq.com have that Dataflow does not:

- Secure, sandbox notebooks served over HTTPS
- Hosting several notebooks at a time
- Multiplayer editing
- Database Connections
- Customer Support
- A vibrant, welcoming community (very important!)
- Inlined source code and a web-based editor (Dataflow is bring-your-own editor)

And here are some features that Dataflow Observable notebooks have that observablehq.com notebooks do not:

- Use whatever text editor or IDE you want
- Save "Observable Javascript" to actual files (very git and version control friendly)
- Tree-shaking
- LiveFileAttachments
- Custom Standard Libraries
- Non-iframe'd notebook (access to Bluetooth APIs, \`document.title\` / \`window.location.hash\`, etc.)
- Complete customizability of rendered notebook

### Security Notes

Here's a few things I wouldn't do with dataflow:

1) Run an \`.ojs\` file with \`dataflow run\` that I have not read/inspected myself (ie, not random )



### y tho

### Future of Dataflow

I still plan to make more updates and new features for Dataflow, if people end up using it. 
`

reference = () => md`## Reference

### Command Line Interface

#### \`dataflow run\`

- \`--allow-file-attachments\`
- \`--stdlib <path>\`
- \`--allow-secrets\`
- \`--secret [secret...]\`
- \`-p, --port <nnumber>\`
- \`--no-open\`

#### \`dataflow compile\`

- \`--stdlib <path>\`
- \`--target <cells>\`
- \`--tree-shake <cells>\`
- \`--bundle\`

### Node API

This is a work in progress! I hope to expose some functions to make it easier to integrate Dataflow operations into other projects. Checkout [#6](https://github.com/asg017/dataflow/issues/6) if you have any ideas/feature request with a Node API!`

pages = [intro, quickstart, importing,  fileattachments, stdlib, secrets, compiling, production, reference]

function toc() {
  return html`<aside class="toc-container">
    <ul class="toc">
      ${pages.map( (p,i) => {
        const page = p();
        function onClick(){
          mutable currentI = i;
        }
        const header = (page.querySelector("h2") || page).textContent;
        const subs = Array.from(page.querySelectorAll("h3")).map(d=>d.textContent);

        return html`<li class="toc-item toc-item-${i}" onClick=${onClick}>
          <span class=head>${header}</span>
          <ul class="toc-sub">
            ${subs.map(s=>html`<li>${s}`)}
          </ul>
        </li>` 
      })}
  </ul>`
}

styleTOC = html`<style>
.toc-item-${currentI} {
  color: purple;
}`


html`<style> 
#dataflow-container {
  width: 100%;
  max-width: 100%;
  margin: 0;
  padding: 0;
  overflow: unset;
}
`

style = html`
<link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/boxicons@latest/css/boxicons.min.css">

<style>
body {
  padding: 0;
  margin: 0;
}
.observablehq {
  overflow: unset; /* fucks with position sticky */
}

#title {
  border: none;
  padding: 0;
  margin: 0; 
  height: 3rem;
}

.nav-parent {
  position: sticky; 
  postion: -webkit-sticky;
  top: 0; 
  z-index: 20;
}

nav {
  background-color: #67a9cf; 
  position: sticky; 
  top: 0; 
  z-index: 20;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-left: 2rem;
  padding-right: 4rem;
}
.container {
  display: grid; 
  grid-template-columns: 18rem minmax(auto, 800px);
  grid-gap: 1rem;
  height: 100%;
  margin-top: 3rem;
}
.toc-container {
  height: 100vh;
  position: sticky;
  display: block;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
}
.toc {
  border-right: 1px solid #ccc;
  height: 100%;
}
.toc-sub {
  font-size: .95rem;
  padding: 0;
  padding-left: .5rem!important;
}
.toc-item {
  font-size: 1.1rem;
  cursor: pointer;
}
.toc-item .head {
  font-weight: 600;
}
.toc li:hover {
  background-color: lavender;
}
.content {
  width: 100%;
  max-width: 48rem;
  margin: 0 auto;
  padding: 0 .5rem;
}

.version {
  font-size: 1rem;
  font-weight: 600;
  font-family: Monospace;
  background: #ccc;
  letter-spacing: -2px;
  padding: .125rem .25rem;
  border-radius: .25rem;
  margin-bottom: .25rem;
}`
